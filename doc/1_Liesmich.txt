Liesmich zum Referenzprojekt 

Versandetiketten-Erstellung
---------------------------

von Ralf Peine

Stand: 16.11.2022

-----------------------------------------------------------------------

Ticket_VersandEtiketten.txt - beschreibt die (Übungs-)Aufgabe.

-----------------------------------------------------------------------

"OffenePunkte.txt" entstand ebenso während der Entwicklung
wie die drei PDF-Downloads hier vom Internationalen Postverein UPU.

-----------------------------------------------------------------------

Kommentare, die mit //i/ (i für info) starten,
enthalten Erläuterungen zu dieser Referenzimplementierung,
sie würden in Produktiv-Code entfallen.

-----------------------------------------------------------------------

Entwicklungsumgebung

Eclipse IDE for Java Developers (includes Incubating components)
Version: 2022-09 (4.25.0)

-----------------------------------------------------------------------

Diese Implementierung der Übungsaufgabe verwendet

-----------------------
IODA nach Ralf Westphal
-----------------------

kurze Intro:

IODA teilt alle Klassen in die Typen

Integrator
Operation
Daten
API

ein.

*Integratoren* dürfen jeden anderen Klassentyp aufrufen, enthalten
aber keine Logik.

*Operationen* dürfen nur *Daten* verwenden und manipulieren 
sowie die *API* aufrufen.
Sie dürfen keine anderen *Operationen* oder gar *Integratoren* aufrufen.
Sie enthalten als einzige Klassen (komplexere) Logik.
Daraus folgt auch, das *Operationen* direkt keine *IO-Operationen* aufrufen dürfen.

*Daten* beschäftigen sich nur mit sich selbst, ihren Kindern, Enkeln usw.
Außerhalb der Familie ist nur der Zugriff auf das API erlaubt.

Das *API* hat keinen Zugriff auf *Integratoren*, *Operationen* oder *Datenklassen*,
es ist wie eine Standard-Library des Entwicklungs-Systems zu betrachten
und zu behandeln.
Das *API* darf aber niedriger gelegene *APIs* aufrufen,
z.B. Standard-Libraries des Entwicklungs-Systems.

https://blog.ralfw.de/2015/04/die-ioda-architektur.html

----------------

Meine Erweiterung nach dem EVA-Prinzip (Eingabe - Verarbeitung - Ausgabe):

Trennung der Operationen mit IO und ohne IO in verschiedene Bereiche/Libraries.

IO - Input/Output - Eingabe/Ausgabe
-----------------------------------

Ruft ein Operator über die API IO-Funktionalität auf,
sollte er nur Logik enthalten,
die der Bedienung der IO-Funktionen dient.

Verarbeitung
------------

Enthält ein Operator Verarbeitungs-Logik,
darf er keine IO-Funktionalitäten aufrufen.

--------------------------------------------------------------------------------------

Vorteile des IODA-Ansatzes, u.a.
- leichte Testbarkeit in Unit-Tests
- kein Mocking oder Ähnliches mehr erforderlich
- Verminderung der Komplexität
- Entkopplung durch eigene Libraries möglich
- klare Struktur

--------------------------------------------------------------------------------------

---------------------------------------
Benennung der Testklassen und -Methoden
---------------------------------------

Um Namenskonflikte zu vermeiden und zum leichteren Auffinden der Testklassen und -methoden
verwende ich folgende Nomenklatur:

Klassen
-------

* TCA_0000_NameDerGetestetenKlasse
  TCA = TestClassApi - Test einer Klasse aus dem API
  0000 => Nummerierung der Klassen für eine Sortierung der Ausführungsreihenfolge
  
* TCL_0000_NameDerGetestetenKlasse
  TCL = TestClass - Test einer Klasse

* TCIO_0000_NameDerGetestetenKlasse
  TCIO = TestClassIO - Test einer Klasse mit IO Funktionalitäten
  
Methoden
--------
* T0001_MeineMethode1
  T für Test
  0000 => Nummerierung der Tests für eine Sortierung der Ausführungsreihenfolge

* T0100_MeineMethode2

Eine Test-Methode darf alle Methoden des Testobjekts verwenden,
die bereits in Tests mit niedrigerer Nummer getestet worden sind.
Bei auftretenden Fehlern ist zuerst der mit der niedrigsten Nummer zu beheben.
Evtl. funktionieren danach einige oder alle Tests wieder.

Beispiel IO-Test
----------------

T010_CreateKunde - darf nur testObject.CreateKunde aufrufen
T020_ReadKunde   - darf testObject.CreateKunde verwenden
T030_UpdateKunde - darf testObject.CreateKunde und ReadKunde verwenden
T040_DeleteKunde - darf testObject.CreateKunde, ReadKunde und UpdateKunde verwenden

T100_SelectKunden - darf testObject.CreateKunde, ReadKunde, UpdateKunde und DeleteKunde verwenden

Dadurch sind die Tests nicht mehr ganz unabhängig,
doch sonst müsste T020_ReadKunde per direktem SQL (oder irgendwie anders)
einen Kunden in der Datenbank anlegen,
um ihn anschließend einlesen zu können.

Das führt zu doppelter Implementierung, z.B. in einem Test-Fixture.
Und wie wird sichergestellt, dass das Test-Fixture keine Fehler bei der Anlage der Kunden macht??

Ebenso benötigt T100_SelectKunden mehrere Kunden in der Datenbank.

Oft werden die 4 CRUD-Tests zusammengefasst zu einem TestCase:

T010_CRUD_Kunde - Create - Read - Update - Delete werden in einem einzigen Test ausgeführt
und jeder einzelne Schritt geprüft:

void T010_CRUD_Kunde () {

  string kundeNr = "K4711";
  
  Kunde kunde = createKundeInMemory(kundeNr);
  OrmManager testObject = new OrmManager();
  
  // --- Test Create ----------
  testObject.Create(kunde);
  
  // --- Test Read ----------
  Kunde kundeRead = testObject.Read(kundeNr);
  
  Assert.AreEqual(kunde.KundeNummer, kundeRead.KundeNummer);
  Assert.AreEqual(kunde.Vorname, kundeRead.Vorname);
  Assert.AreEqual(kunde.Name, kundeRead.Name);
  
  // --- Test Update ----------
  Kunde kundeToUpdate = testObject.Read(kundeNr);
  
  kundeToUpdate.Name = "NameNeu";
  
  testObject.Update(kundeToUpdate);
  
  Kunde kundeNachUpdate = testObject.Read(kundeNr);
  
  Assert.AreEqual(kundeToUpdate.Name, kundeNachUpdate.Name);
  
  // --- Test Delete ----------
  testObject.Delete(kundeNr);
  
  Kunde kundeDeleted = testObject.Read(kundeNr);
  
  Assert.AreEqual(null, kundeDeleted);
}
  