<!doctype html>
<html lang="de">
	<head>
		<title>Meine Implementierung - IODA und TDD mit Java</title>
	</head>
	<body>
		<header>
			<p>Meine Implementierung - IODA und TDD mit Java</p>
			<hr/>
		</header>
		<h1>Meine Implementierung</h1>
		
		<h2>Entwicklungsumgebung</h2>

		<p>Eclipse IDE for Java Developers (includes Incubating components)<br />
		Version: 2022-09 (4.25.0)
		</p>
		
		<h2>Historie der Entwicklung</h2>
		
		<p>Im Folgenden beschreibe ich grob die Historie, wie ich was in welcher Reihenfolge umgesetzt habe.
			Diese Reihenfolge ist natürlich nur eine mögliche Variante, die Software zu erstellen.
			Es zählt einzig das Endergebnis.
		</p>
			
		<ul>
			<li>Objektorientierung</li>
			<li>TDD - Test Driven Development - <a href="mein-TDD.html">Mein Ansatz wird hier kurz beschrieben</a></li>
			<li><a href="https://de.wikipedia.org/wiki/Clean_Code">Clean Code</a> (Wikipedia)</li>
			<li><a href="https://de.wikipedia.org/wiki/EVA-Prinzip">EVA-Prinzip / IPO-Model</a> (Wikipedia)</li>
			<li>IODA - <a href="ioda.html">hier kurz beschrieben</a></li>
			<li><a href="https://de.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself">DRY - Don’t repeat yourself</a>
			    (Wikipedia) - Vermeidung / Reduzierung von Redundanz</li>
			<li>Ableitung nur für Interfaces - <a href="keine-Ableitungen.html">hier kurz beschrieben</a></li>
		</ul>
		<p>Vor der Codierung muss zuerst die Aufgabenstellung verstanden werden.
			In diesem einfachen Fall ist das gut möglich. In echten Projekten muss die Aufgabenstellung
			oft gemeinsam erarbeitet werden, bisweilen sogar iterativ mit Prototypen
			oder leichten Implementierungen.<p>
		
		<h2>1. Analyse des Tickets und der Aufgabenstellung</h2>
		
		<p>Zunächst sind die einzelnen Schritte aus dem Ticket zu lesen. Dazu habe ich die 
		  <a href="ticket-4711-formatiert.html"> Beschreibung im Ticket umgebrochen</a>
		  .</p>
		
		<p>Als zweites ist zu klären, wie denn eine Anschrift aufgebaut werden sollte,
		   nach den jeweils gültigen Richtlinien.
		   Doch wer legt diese Richtlinien fest? Die "Deutsche Post" 
		   kann ja wohl nur für Deutschland zuständig sein?
		   Hier ist ein wenig Recherche im Web erforderlich.
		  </p>
				
		<p>Die Richtlinien für den Aufbau von Adressen legt der 
		  <a href="https://de.wikipedia.org/wiki/Weltpostverein">Weltpostverein</a> fest,
		  <a href="https://www.upu.int/en/Home">www.upu.int</a>.
		  Alle anderen Richtlinien im Web sollten darauf aufbauen.
		  </p>
		  <p>Für die Probeaufgabe würde ich auch andere Quellen akzeptieren.
		  </p>
		  <p>
		  Doch die Entwicklung durchzuführen, <i>ohne irgendwelche Richtlinien zu zitieren</i>,
          das wäre mir deutlich zu wenig. Denn in diesem Fall wäre der Aufbau der Adressen
		  allein durch den Code festgelegt. Wogegen soll das dann später getestet werden?
		  </p>
				
		<p>Vom Welpostverein habe ich mir nun die passenden Richtlinien für den Aufbau 
		  der Anschriften für Deutschland,
		  Spanien und UK heruntergeladen
		  und im Ordner "doc" des Projektes abgelegt:
		  </p>
		<p>
			<a href="../doc">Zum Ordner ../doc</a>
		</p>
		<h2>2. Entwicklung</h2>
		
		<h3>Generelle Hinweise</h3>
		
		<p>Kommentare, die mit //i/ (i für info) starten,
			enthalten Erläuterungen zu dieser Referenzimplementierung,
			sie würden in Produktiv-Code entfallen.
		</p>
		
		<p>Die Datei <a href="../doc/OffenePunkte.txt">OffenePunkte.txt</a>
			enthält offene Punkte oder Fragen, die während der Entwicklung aufgekommen sind.
		</p>
		
		<h3>a. Entwicklung mittels Stubs</h3>
		
		<p>Da ich anfangs noch keine Unit-Tests entwickeln konnte,
		   habe ich direkt mit dem Produktiv-Code begonnen.
		</p>
		<p>Ein Middleware-Stub liefert die Daten, aus denen dann die Anschrift erstellt
			und danach an einen Drucker-Stub weitergereicht wird.
			Der Drucker Stub gibt dann die Anschrift einfach auf der Console aus.
		  </p>
		<p>In einem realen Projekt hat man üblicherweise bereits Schnittstellen zur Middle-Ware, 
		     eine Datenbank oder XML-Daten, auf
			 die man zugreifen kann. Ebenso ist davon auszugehen, dass es bereits einen Drucker bzw.
			 eine Drucker-Schnittstelle gibt.
		  </p>
		<p>
			 Das gibt es hier in einem solchen Demo-Projekt nicht und 
			 deshalb - NUR deshalb - müssen hier auch diese
			 beiden Stubs entwickelt werden.
		  </p>
		<p>
			 Es zeigt sich im weiteren Verlauf, dass auch Code-First funktionieren kann.
			 Im klassischen TDD gilt ja Test-First.
			 Ich selbst ziehe es vor, Code und Tests beide nach und nach zu entwickeln.
		  </p>
		  
		<h3>b. Entwicklung der Tests und Redesign</h3>
		
		<p>Nachdem die ersten Versionen der Software liefen, habe ich das Unit-Testing eingefügt
			 und immer wieder Einiges umgestellt, Methoden ins API extrahiert, Factories eingefügt
			 und Anderes. Das ist der übliche Prozess, damit der Produktiv-Code besser testbar wird.
		  </p>
		  
		<h3>c. IO: Daten aus XML lesen</h3>
		
		<p>Der nächste Schritt war eine Umstellung im Middleware-Stub: 
		     Von programmatisch generierten Daten auf Dateien, die per
			 XML in die Datenklassen eingelesen werden können. 
			 Dazu mussten die Daten natürlich auch in XML geschrieben werden.
			 Leider sind die so erzeugten XML-Dateien nicht so gut lesbar wie die XML-Dateien, 
			 die mit C# und den Standard .NET-Klassen erstellt werden.
		  </p>
		<p>Im Sinne der reinen Aufgabenstellung wäre das natürlich gar nicht notwendig gewesen,
			 aber mir geht es hier auch darum, meine Anwendung des
			 <a href="https://de.wikipedia.org/wiki/EVA-Prinzip">EVA-Prinzips</a>
			 zu zeigen, das unter anderem besagt, dass Eingabe und Ausgabe <b>unbedingt</b>
			 von der Verarbeitung zu trennen sind.
		  </p>
		<p>Ich wende dieses Prinzip nicht nur im Großen, sondern auch im ganz Kleinen an.
        </p>
		<p>So trenne ich in realen Projekten IO von den Verarbeitungs-Klassen.
			 IO wird grundsätzlich in eigenen Operator-Klassen durchgeführt 
			 und meistens sogar in eigene Libraries ausgelagert.
			 Denn IO-Funktionalität ist aufwendiger und vor allem langsamer zu testen.
		  </p>
		<p>		
		   Diese Auslagerung der IO-Funktionalität hat unter anderem große Vorteile im Unit-Testing.
		   Da alle anderen Operator-Klassen (Verarbeitungs-Klassen) keinen Zugriff auf IO haben,
		   müssen ihnen alle Daten von außen
		   hereingegeben werden. Dadurch wird die Software klarer und die Tests können sich die 
		   Daten einfach selbst als Instanzen von Datenklassen erzeugen. 
		  </p>
		  
		<h3>d. Testfälle komplettieren</h3>
		
		<p>Im letzten großen Schritt wurden die Testfälle komplettiert, 
			 was die Funktionalität einerseits und die Code-Überdeckung andererseits betraf.
		  </p>
		<footer>
			<hr/>
			<a href="kontakt.html">Kontakt</a>
		</footer>
	</body>
</html>