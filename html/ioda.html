<!doctype html>
<html lang="de">
	<head>
		<title>IODA Kurzbeschreibung - IODA und TDD mit Java</title>
	</head>
	<body>
		<header>
			<p>IODA Kurzbeschreibung - IODA und TDD mit Java</p>
			<hr/>
		</header>
		<h1>IODA</h1>

		<p><b><i>Funktionale Abhängigkeiten sind böse!</i></b>
		<p>
		
		<p>Dieses Zitat von Ralf Westphal ist für mich wesentlich, weil
		   sich genau das immer wieder in meiner Arbeit bestätigt hat.</p>
		
		<p>Ziel des IODA-Ansatzes ist es daher, diese funktionalen Abhängikeiten 
		zwischen einzelnen Klassen und Bereichen
		in der Software zu regeln und zu minimieren.
		Daraus ergeben sich dann weitere Vorteile.</p>
		
		<h2>Vorteile des IODA-Ansatzes</h2>
		
		<ul>
			<li>Minimierung der funktionalen Abhängikeiten</li>
			<li>Leichtere Wartung des Codes</li>
			<li>Verminderung der Komplexität</li>
			<li>Entkopplung durch eigene Libraries möglich</li>
			<li>klare SW-Struktur</li>
			<li>leichte Testbarkeit in Unit-Tests</li>
			<li>kein Mocking oder Ähnliches mehr erforderlich</li>
			
		</ul>
		
		<h2>IODA nach Ralf Westphal</h2>
		
		<p>Ralf Westphal hat um 2015 herum IODA entwickelt/erfunden, 
		um diese <i>Funktionalen Abhängigkeiten</i> zu eliminieren oder
		zumindest auf das notwendige Minimum zu beschränken.
		</p>
		<p>Hier der <a href="https://blog.ralfw.de/2015/04/die-ioda-architektur.html">
        Link auf seinen Artikel</a>.
		</p>
		
		<p>Zusammenfassung des IODA Ansatzes als Zitat aus dem Artikel:</p>
		
		<p><b><i>So entsteht Software als Summe von Prozessen, 
		   deren Schritte in Operationen implementiert sind, 
		   die Daten konsumieren und produzieren unter Zuhilfenahme von APIs.
		   </i></b>
		</p>
		
		<p>Für alle, die nicht den gesamten Artikel lesen möchten, hier eine sehr kurze
		Einführung:
		</p>
		
		<h2>Kurze IODA Intro</h2>
		
		<p>IODA teilt alle Klassen in die Typen
		</p>
		<ul>
			<li>Integrator</li>
			<li>Operation</li>
			<li>Daten</li>
			<li>API</li>
		</ul>
		<p>ein. Zugriff ist nur von "Oben nach Unten" erlaubt.
		</p>
		
		<h3>Integratoren</h3>
			<p>
				<i>Integratoren</i> dürfen jeden anderen Klassentyp aufrufen, enthalten
			aber keine Logik.
			</p>
			
		<h3>Operationen</h3>
			<p>
				<i>Operationen</i> dürfen nur <i>Daten</i> verwenden und manipulieren 
			sowie die <i>API</i> aufrufen.
			Sie dürfen keine anderen <i>Operationen</i> oder gar <i>Integratoren</i> aufrufen.
			Sie enthalten als einzige Klassen (komplexere) Logik.
			Daraus folgt auch, dass <i>Operationen</i> direkt keine <i>IO-Operationen</i> aufrufen dürfen.
			</p>
			
		<h3>Daten</h3>
			<p>
				<i>Daten</i> beschäftigen sich nur mit sich selbst, ihren Kindern, Enkeln usw.
			Außerhalb der Familie ist nur der Zugriff auf das API erlaubt.
			</p>
			
		<h3>API</h3>
			<p>Das <i>API</i> hat keinen Zugriff auf <i>Integratoren</i>, <i>Operationen</i> oder <i>Datenklassen</i>,
			es ist wie eine Standard-Library des Entwicklungs-Systems zu betrachten
			und zu behandeln.
			</p>
			<p>Das <i>API</i> darf aber niedriger gelegene <i>APIs</i> aufrufen,
			z.B. Standard-Libraries des Entwicklungs-Systems.
			</p>
			
		<img src="IODA.png" />
			
		<h2>Meine Erweiterung nach dem EVA-Prinzip</h2>
		
			<p>Die Operationen mit IO werden von den Operationen ohne IO getrennt 
			und idealerweise in verschiedenen Libraries abgelegt.
			</p>
			
			<h3>IO-Operationen</h3>
			
			<p>Ruft eine Operation über die <i>API IO-Operationen</i> (der API) auf,
				so wird sie als <i>IO-Operation</i> gewertet.
				Dazu gehören z.B. Schreib- und Lesezugriffe auf Datenbanken, Dateien, die Konsole.
			</p>
			
			<p><i>IO-Operationen</i> sollten nur Logik enthalten, die der Bedienung der IO-Funktionalität dienen,
			   und selbst keine Verarbeitungslogik enthalten.
			</p>
			
			<h3>Verarbeitungs-Operationen</h3>
			
			<p>Einer <i>Verarbeitungs-Operation</i> werden sämtliche Daten als <i>Instanzen von Datenklassen</i>
			   beim Aufruf übergeben.
			   Es werden von der Operation keinerlei weitere Daten von irgendwoher beschafft
			   oder irgendwohin abgelegt. Die Ergebnisse der Verarbeitung werden als 
			   <i>Instanzen von Datenklassen</i> zurückgeliefert.
			<p>
			
		<h2>Analogie zur Fabrik</h2>
		
		<p>
		In einer Fabrik werden Holzrohlinge mit Sägen oder komplexen 5-Achs-Fräs-Maschinen verarbeitet.
		</p>
		<p>
		Der Rohling wird von einem Mitarbeiter im Lager ausgesucht und dann in einer Gitterbox 
		gemeinsam mit anderen Rohlingen in die Fabrikhalle gefahren. Das ist eine IO-Operation.
		</p>
		<p>
		Die Integratoren führen dann den weiteren Materialfluss durch und liefern das Holz-Werkstück
        zuerst zur maschinellen Säge und danach zu einer anderen Maschine, dem 5-Achs-Fräser.
		</p>
		<p>
		Diese Maschinen bilden die Operationen,
		</p>
		<p>
        und die Holzwerkstücke die Daten.
		</p>
		<p>
		Die Stromversorgung kann als API interpretiert werden, auf das auch die Operatoren Zugriff haben.
		</p>
		<p>
		Wenn aus dem Werkstück ein geschwungener Handlauf eines Treppengeländers entstanden ist,
		</p>
		<p>
		kann dieser von der Versandabteilung verpackt und verschickt werden. Die Versandabteilung bildet damit
		einen weiteren Teil der IO-Funktionalität ab.
		</p>
		<p>
		Als weitere Variante einer Operation kann ein einfacheres Teil 
		auch in manuellen Arbeitsschritten erstellt werden. Dazu werden dem Handwerker Holz und Schrauben geliefert.
		</p>
		<p>
		Der Arbeiter verwendet nur Standard-Werkzeuge (aus der API):
		Zuerst eine Stichsäge, dann eine Bohrmaschine
		und zum Schluss einen Akkuschrauber.
		</p>
	
		<footer>
			<hr/>
			<a href="kontakt.html">Kontakt</a>
		</footer>
	</body>
</html>